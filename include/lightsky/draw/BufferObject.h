/* 
 * File:   draw/BufferObject.h
 * Author: Miles Lacey
 *
 * Created on March 31, 2014, 8:00 PM
 */

#ifndef __LS_DRAW_BUFFER_OBJECT_H__
#define	__LS_DRAW_BUFFER_OBJECT_H__

#include <cstddef> // ptrdiff_t

#include "lightsky/setup/macros.h"

#include "lightsky/utils/pointer.h"

#include "lightsky/draw/Setup.h"
#include "lightsky/draw/VertexAttrib.h"

namespace ls {
namespace draw {

/*-----------------------------------------------------------------------------
 * Forward Declarations
-----------------------------------------------------------------------------*/
class BufferObject;
enum common_vertex_t : unsigned;
enum index_element_t : int;

/*-----------------------------------------------------------------------------
 * Typedefs
-----------------------------------------------------------------------------*/
typedef BufferObject VertexBuffer;
typedef BufferObject IndexBuffer;
typedef BufferObject TransformBuffer;
typedef BufferObject UniformBuffer;

/*-----------------------------------------------------------------------------
 * Enumerations
-----------------------------------------------------------------------------*/
/**
 * @brief This enumeration outlines the basic types of buffers are available
 * for use in a render context. It will be updated as more features are
 * written.
 */
enum buffer_use_t : GLenum {
    VBO_BUFFER_ARRAY                = GL_ARRAY_BUFFER,
    VBO_BUFFER_ELEMENT              = GL_ELEMENT_ARRAY_BUFFER,
    VBO_BUFFER_TRANSFORM_FEEDBACK   = GL_TRANSFORM_FEEDBACK_BUFFER,
    VBO_BUFFER_UNIFORM_BUFFER       = GL_UNIFORM_BUFFER
};

/**
 * @brief Different usage parameters that determine how a buffer may be used.
 */
enum buffer_access_t : GLenum {
    VBO_STATIC_READ     = GL_STATIC_READ,
    VBO_STATIC_DRAW     = GL_STATIC_DRAW,
    VBO_STATIC_COPY     = GL_STATIC_COPY,
    
    VBO_STREAM_READ     = GL_STREAM_READ,
    VBO_STREAM_DRAW     = GL_STREAM_DRAW,
    VBO_STREAM_COPY     = GL_STREAM_COPY,
    
    VBO_DYNAMIC_READ    = GL_DYNAMIC_READ,
    VBO_DYNAMIC_DRAW    = GL_DYNAMIC_DRAW,
    VBO_DYNAMIC_COPY    = GL_DYNAMIC_COPY,
    
    VBO_COPY_READ       = GL_COPY_READ_BUFFER,
    VBO_COPY_WRITE      = GL_COPY_WRITE_BUFFER
};

/**
 * @brief Memory mapping bit flags used for DMA transfers between CPU and GPU
 * memory.
 */
enum buffer_map_t : GLbitfield {
    VBO_MAP_BIT_READ                = GL_MAP_READ_BIT,
    VBO_MAP_BIT_WRITE               = GL_MAP_WRITE_BIT,
    VBO_MAP_BIT_INVALIDATE_RANGE    = GL_MAP_INVALIDATE_RANGE_BIT,
    VBO_MAP_BIT_INVALIDATE_BUFFER   = GL_MAP_INVALIDATE_BUFFER_BIT,
    VBO_MAP_BIT_FLUSH_EXPLICIT      = GL_MAP_FLUSH_EXPLICIT_BIT,
    VBO_MAP_BIT_UNSYNCHRONIZED      = GL_MAP_UNSYNCHRONIZED_BIT
};

/**----------------------------------------------------------------------------
 * @brief GPU Buffer Object
 * 
 * This object provides a more robust interface to OpenGL vertex buffer
 * objects. Different VBO types can be generated by modifying the template
 * parameter.
-----------------------------------------------------------------------------*/
struct BufferObject {
    /**
     * @brief A handle to the vertex buffer object residing on the GPU.
     */
    uint32_t gpuId;
    
    /**
     * @brief bufferType is used to determine if *this is a Vertex Buffer
     * Object, an Index Buffer Object, or anything else.
     */
    buffer_use_t bufferType;
    
    /**
     * @brief numAttribs should contain the number of attributes/members per
     * element in *this object's buffer.
     * 
     * This member should directly correlate to the number of items in the
     * "pAttribs" member.
     */
    uint32_t numAttribs;
    
    /**
     * @brief pAttribs contains a CPU-side representation of the per-vertex
     * attributes used by each element in *this object's GPU memory.
     */
    utils::pointer<VertexAttrib[]> pAttribs;
    
    /**
     * @brief Destructor
     * 
     * Releases all resources used by *this.
     */
    ~BufferObject() = default;

    /**
     * @brief Constructor.
     */
    BufferObject();

    /**
     * @brief Copy Constructor
     * 
     * Creates a buffer object on the GPU for *this, the copies data from the
     * input parameter.
     * 
     * @param b
     * A buffer object whose data will be copied into *this object's GPU memory.
     */
    BufferObject(const BufferObject& b);

    /**
     * @brief Move Constructor
     * 
     * This moves the data contained within the constructor parameter into
     * *this. No copies are performed.
     * 
     * @param b
     * A buffer object whose data will be moved into *this.
     */
    BufferObject(BufferObject&& b);

    /**
     * @brief Copy Operator
     * 
     * Discards any old data which was referenced by *this on the GPU, then
     * reallocates and copies data from the input parameter.
     * 
     * @param b
     * A buffer object whose data will be copied into *this object's GPU memory.
     * 
     * @return A reference to *this.
     */
    BufferObject& operator=(const BufferObject& b);

    /**
     * @brief Move Operator
     * 
     * This moves the data contained within the method parameter into *this.
     * No copies are performed.
     * 
     * @param b
     * A vertex buffer object whose data will be moved into *this.
     */
    BufferObject& operator=(BufferObject&& b);
};

/*-----------------------------------------------------------------------------
 * Buffer Object Loose Functions
-----------------------------------------------------------------------------*/
/**
 * @brief Buffer initialization.
 * 
 * Generates a vertex buffer object on the GPY that will be used to
 * contain a large pool of data.
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 * 
 * @return TRUE if the buffer was successfully created, FALSE if not.
 */
bool init_buffer(BufferObject& buf);

/**
 * @brief Terminate the vertex buffer and release all of its resources back to
 * the GPU.
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 */
void terminate_buffer(BufferObject& buf);

/**
 * @brief Determine if there is data used by this object
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 * 
 * @returns true if this object has data residing on GPU memory, false
 * if not.
 */
inline bool is_buffer_valid(const BufferObject& buf) {
    return buf.gpuId != 0;
}

/**
 * @brief Bind a vertex buffer to the current global rendering context.
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 */
inline void bind_buffer(const BufferObject& buf) {
    glBindBuffer(buf.bufferType, buf.gpuId);
}

/**
 * @brief Unbind a vertex buffer object from the current render context.
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 */
inline void unbind_buffer(const BufferObject& buf) {
    glBindBuffer(buf.bufferType, 0);
}

/**
 * @brief Set the data within the buffer to whatever is set at "pData."
 * 
 * @param size
 * The size, in bytes, of the data that the buffer should contain.
 * 
 * @param pData
 * A pointer to the data contained within the buffer. This argument can
 * be NULL to indicate that an empty buffer should be allocated and
 * will have its contents filled later.
 * 
 * @param usage
 * The usage of this buffer. This can indicate that the buffer is
 * static, should be used to stream data occasionally, or the data is
 * dynamic and will be updated on a regular basis.
 * 
 * @return TRUE if the buffer was successfully allocated, FALSE if not.
 */
inline void set_buffer_data(
    const BufferObject& buf,
    const ptrdiff_t size,
    const void* const pData,
    const buffer_access_t usage
) {
    glBufferData(buf.bufferType, size, pData, usage);
}

/**
 * @brief Modify the data within a buffer to contain whatever is in "pData."
 * at an offset of a specified amount of bytes.
 * 
 * @param size
 * The size, in bytes, of the data that the buffer should contain.
 * 
 * @param offset
 * The offset, in bytes, to where the data should be placed in *this.
 * 
 * @param pData
 * A pointer to the data contained within the buffer.
 * 
 */
inline void set_buffer_sub_data(
    const BufferObject& buf,
    const ptrdiff_t offset,
    const ptrdiff_t size,
    const void* const pData
) {
    glBufferSubData(buf.bufferType, offset, size, pData);
}

/**
 * @brief Copy the GPU data from one buffer object into another.
 * 
 * @param from
 * A constant reference to a buffer object which contains GPU data.
 * 
 * @param to
 * A reference to a buffer object which will allocate and contain the same GPU
 * data as the input parameter.
 */
bool copy_buffer_data(const BufferObject& from, BufferObject& to);

/**
 * @brief Determine how much memory (in bytes) is currently being used by a
 * buffer on the GPU.
 * 
 * @param buf
 * A constant reference to a buffer object who's memory information is to be
 * queried.
 * 
 * @return An unsigned integer containing the number of bytes used by a buffer
 * object on the GPU.
 */
inline ptrdiff_t get_buffer_size(const BufferObject& buf) {
    GLint numBytes = 0;
    glGetBufferParameteriv(buf.bufferType, GL_BUFFER_SIZE, &numBytes);
    return numBytes;
}

/**
 * @brief Retrieve the current usage of a BufferObject.
 * 
 * This usage can help to determine if the data in a buffer is static, dynamic,
 * streamed, readable, writable, copy-able, etc.
 * 
 * @param buf
 * A constant reference to a buffer object who's usage information is to be
 * queried.
 * 
 * @return An enumeration of the buffer_access_t type.
 */
inline buffer_access_t get_buffer_usage(const BufferObject& buf) {
    unsigned usage = 0;
    glGetBufferParameteriv(buf.bufferType, GL_BUFFER_USAGE, (GLint*)&usage);
    return (buffer_access_t)usage;
}

/**
 * @brief Map the contents of the buffer into memory in order to perform a DMA
 * transfer of data to the GPU.
 * 
 * @param buf
 * A reference to the buffer object who's data is to be manipulated.
 * 
 * @param offset
 * The offset, in bytes, to where the data should be placed in *this.
 * 
 * @param range
 * The range of bytes that will be mapped to memory.
 * 
 * @param access
 * Specifies a combination of access flags indicating the desired
 * access to the range of memory.
 * 
 * @returns void*
 * A pointer to the location in memory where the data will be mapped.
 * A NULL pointer may be returned, indicating an error that may have
 * occurred while attempting to map the buffer to memory.
 * 
 */
inline void* map_buffer_data(
    const BufferObject& buf,
    const ptrdiff_t offset,
    const ptrdiff_t range,
    const buffer_map_t access
) {
    return glMapBufferRange(buf.bufferType, offset, range, access);
}

/**
 * @brief Notify the GPU that all data has been uploaded to the requested
 * location in memory and that the DMA transfer can now be performed.
 * 
 * @param buf
 * A constant reference to the buffer object who's data is to be manipulated.
 */
inline bool unmap_buffer_data(const BufferObject& buf) {
    return glUnmapBuffer(buf.bufferType);
}

/**
 * @brief Setup all vertex attributes that will be associated with a
 * BufferObject.
 * 
 * These attributes can be used to setup draw calls or be used as binding
 * information for a Vertex Array Object.
 * 
 * @param buf
 * A reference to a BufferObject which is to have an array of vertex attributes
 * placed into it.
 * 
 * @param attribs
 * A bitmask, containing all vertex attribute types which will be used for a
 * buffer object. The order in which the attributes are setup on the GPU
 * follows the same order in which they are defined in the "common_vertex_t"
 * enumeration (see VertexUtils.h).
 * 
 * @return TRUE if all vertex attributes were able to be placed into the
 * BufferObject, FALSE if not.
 */
bool setup_vertex_buffer_attribs(BufferObject& buf, const common_vertex_t attribs);

/**
 * @brief Setup all index buffer attributes that will be associated with a
 * BufferObject.
 * 
 * These attributes can be used to setup vertex array objects which are used in
 * drawing indexed vertices. Index Buffer Objects created through this method
 * are designed to be packed tightly into a single array on the GPU.
 * 
 * @param buf
 * A reference to a BufferObject which is to have an array of vertex attributes
 * placed into it.
 * 
 * @param indexType
 * An enumeration, containing the data type of the indices which will be used
 * for an index buffer object.
 * 
 * @return TRUE if the IBO attributes were able to be placed into the
 * BufferObject, FALSE if not.
 */
bool setup_index_buffer_attribs(BufferObject& buf, const index_element_t indexType);

} // end draw namespace
} // end ls namespace

#endif	/* __LS_DRAW_BUFFER_OBJECT_H__ */
